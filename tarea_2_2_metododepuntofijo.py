# -*- coding: utf-8 -*-
"""Tarea 2.2_MetodoDePuntoFijo.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/12yTIjn6nZdJqugzlYX7nPSRoeBhq243V
"""

#Antonio Josue Rodriguez Falcon

import numpy as np
import matplotlib.pyplot as plt

# Definir la función g(x) para el método de punto fijo
def g(x):
    return (1 - x)**(1/3)

# Criterio de convergencia
def g_prime(x):
    return -(1/3) * (1 - x)**(-2/3)

# Error absoluto
def error_absoluto(x_new, x_old):
    return abs(x_new - x_old)

# Error relativo
def error_relativo(x_new, x_old):
    return abs((x_new - x_old) / x_new)

# Error cuadrático
def error_cuadratico(x_new, x_old):
    return (x_new - x_old)**2

# Método de punto fijo
def punto_fijo(x0, tol=1e-5, max_iter=100):
    iteraciones = []
    errores_abs = []
    errores_rel = []
    errores_cuad = []

    x_old = x0
    for i in range(max_iter):
        x_new = g(x_old)
        e_abs = error_absoluto(x_new, x_old)
        e_rel = error_relativo(x_new, x_old)
        e_cuad = error_cuadratico(x_new, x_old)

        iteraciones.append((i+1, x_new, e_abs, e_rel, e_cuad))
        errores_abs.append(e_abs)
        errores_rel.append(e_rel)
        errores_cuad.append(e_cuad)

        if e_abs < tol:
            break

        x_old = x_new

    return iteraciones, errores_abs, errores_rel, errores_cuad

# Parámetros iniciales
x0 = 0.5
iteraciones, errores_abs, errores_rel, errores_cuad = punto_fijo(x0)

# Imprimir tabla de iteraciones
print("Iteración | x_n      | Error absoluto | Error relativo | Error cuadrático")
print("-----------------------------------------------------------------------")
for it in iteraciones:
    print(f"{it[0]:9d} | {it[1]:.6f} | {it[2]:.6e} | {it[3]:.6e} | {it[4]:.6e}")

# Graficar la convergencia
x_vals = np.linspace(-1, 1, 100)
y_vals = g(x_vals)

plt.figure(figsize=(8, 5))
plt.plot(x_vals, y_vals, label=r"$g(x) = (1 - x)^{1/3}$", color="blue")
plt.plot(x_vals, x_vals, linestyle="dashed", color="red", label="y = x")

# Graficar iteraciones
x_points = [it[1] for it in iteraciones]
y_points = [g(x) for x in x_points]
plt.scatter(x_points, y_points, color="black", zorder=3)
plt.plot(x_points, y_points, linestyle="dotted", color="black", label="Iteraciones")

plt.xlabel("x")
plt.ylabel("g(x)")
plt.legend()
plt.grid(True)
plt.title("Método de Punto Fijo")
plt.savefig("punto_fijo_convergencia.png")
plt.show()

# Graficar errores
plt.figure(figsize=(8, 5))
plt.plot(range(1, len(errores_abs) + 1), errores_abs, marker="o", label="Error absoluto")
plt.plot(range(1, len(errores_rel) + 1), errores_rel, marker="s", label="Error relativo")
plt.plot(range(1, len(errores_cuad) + 1), errores_cuad, marker="^", label="Error cuadrático")

plt.xlabel("Iteración")
plt.ylabel("Error")
plt.yscale("log")
plt.legend()
plt.grid(True)
plt.title("Evolución de los Errores")
plt.savefig("errores_punto_fijo.png")
plt.show()

#Antonio Josue Rodriguez Falcon
#Ejercicio 1

import numpy as np
import matplotlib.pyplot as plt

def g(x):
    return (3*x - 1)**0.5  # Se reescribe la ecuación como x = sqrt(3x - 1)

def error_absoluto(x_new, x_old):
    return abs(x_new - x_old)

def punto_fijo(x0, tol=1e-5, max_iter=100):
    iteraciones = []
    errores = []

    x_old = x0
    for i in range(max_iter):
        x_new = g(x_old)
        error = error_absoluto(x_new, x_old)

        iteraciones.append((i+1, x_new, error))
        errores.append(error)

        if error < tol:
            break

        x_old = x_new

    return iteraciones, errores

# Parámetro inicial
x0 = 1.5
iteraciones, errores = punto_fijo(x0)

# Imprimir tabla de iteraciones
print("Iteración | x_n      | Error absoluto")
print("------------------------------------")
for it in iteraciones:
    print(f"{it[0]:9d} | {it[1]:.6f} | {it[2]:.6e}")

# Graficar función g(x) y la identidad x = y
x_vals = np.linspace(0, 2, 100)
y_vals = g(x_vals)

plt.figure(figsize=(8, 5))
plt.plot(x_vals, y_vals, label=r"$g(x) = \sqrt{3x - 1}$", color="blue")
plt.plot(x_vals, x_vals, linestyle="dashed", color="red", label="y = x")

# Graficar iteraciones
x_points = [it[1] for it in iteraciones]
y_points = [g(x) for x in x_points]
plt.scatter(x_points, y_points, color="black", zorder=3)
plt.plot(x_points, y_points, linestyle="dotted", color="black", label="Iteraciones")

plt.xlabel("x")
plt.ylabel("g(x)")
plt.legend()
plt.grid(True)
plt.title("Método de Punto Fijo")
plt.show()

# Graficar evolución del error
plt.figure(figsize=(8, 5))
plt.plot(range(1, len(errores) + 1), errores, marker="o", label="Error absoluto")
plt.xlabel("Iteración")
plt.ylabel("Error")
plt.yscale("log")
plt.legend()
plt.grid(True)
plt.title("Evolución del Error Absoluto")
plt.show()

#Antonio Josue Rodriguez Falcon
#Ejercicio 2

import numpy as np
import matplotlib.pyplot as plt

def g(x):
    return np.exp(x) / 4  # Función g(x) transformada de e^x - 4x = 0

def error_absoluto(x_new, x_old):
    return abs(x_new - x_old)

def error_relativo(x_new, x_old):
    return abs((x_new - x_old) / x_new)

def punto_fijo(x0, tol=1e-5, max_iter=100):
    iteraciones = []
    errores_abs = []
    errores_rel = []

    x_old = x0
    for i in range(max_iter):
        x_new = g(x_old)
        e_abs = error_absoluto(x_new, x_old)
        e_rel = error_relativo(x_new, x_old)

        iteraciones.append((i+1, x_new, e_abs, e_rel))
        errores_abs.append(e_abs)
        errores_rel.append(e_rel)

        if e_abs < tol:
            break

        x_old = x_new

    return iteraciones, errores_abs, errores_rel

# Parámetro inicial
x0 = 1.0
iteraciones, errores_abs, errores_rel = punto_fijo(x0)

# Imprimir tabla de iteraciones
print("Iteración | x_n      | Error absoluto | Error relativo")
print("--------------------------------------------------")
for it in iteraciones:
    print(f"{it[0]:9d} | {it[1]:.6f} | {it[2]:.6e} | {it[3]:.6e}")

# Graficar función g(x) y y=x
x_vals = np.linspace(0, 2, 100)
y_vals = g(x_vals)

plt.figure(figsize=(8, 5))
plt.plot(x_vals, y_vals, label=r"$g(x) = \frac{e^x}{4}$", color="blue")
plt.plot(x_vals, x_vals, linestyle="dashed", color="red", label="y = x")

# Graficar iteraciones
x_points = [it[1] for it in iteraciones]
y_points = [g(x) for x in x_points]
plt.scatter(x_points, y_points, color="black", zorder=3)
plt.plot(x_points, y_points, linestyle="dotted", color="black", label="Iteraciones")

plt.xlabel("x")
plt.ylabel("g(x)")
plt.legend()
plt.grid(True)
plt.title("Método de Punto Fijo")
plt.show()

# Graficar errores
plt.figure(figsize=(8, 5))
plt.plot(range(1, len(errores_abs) + 1), errores_abs, marker="o", label="Error absoluto")
plt.plot(range(1, len(errores_rel) + 1), errores_rel, marker="s", label="Error relativo")

plt.xlabel("Iteración")
plt.ylabel("Error")
plt.yscale("log")
plt.legend()
plt.grid(True)
plt.title("Evolución de los Errores")
plt.show()

#Antonio Josue Rodriguez Falcon
#Ejercicio 3

import numpy as np
import matplotlib.pyplot as plt

def g(x):
    return np.cos(x)  # Se reescribe la ecuación x = cos(x)

def g_prime(x):
    return -np.sin(x)  # Derivada de g(x)

def error_absoluto(x_new, x_old):
    return abs(x_new - x_old)

def error_relativo(x_new, x_old):
    return abs((x_new - x_old) / x_new)

def punto_fijo(x0, tol=1e-5, max_iter=100):
    iteraciones = []
    errores_abs = []
    errores_rel = []

    x_old = x0
    for i in range(max_iter):
        x_new = g(x_old)
        e_abs = error_absoluto(x_new, x_old)
        e_rel = error_relativo(x_new, x_old)

        iteraciones.append((i+1, x_new, e_abs, e_rel))
        errores_abs.append(e_abs)
        errores_rel.append(e_rel)

        if e_abs < tol:
            break

        x_old = x_new

    return iteraciones, errores_abs, errores_rel

x0 = 0.5
iteraciones, errores_abs, errores_rel = punto_fijo(x0)

print("Iteración | x_n      | Error absoluto | Error relativo")
print("---------------------------------------------------")
for it in iteraciones:
    print(f"{it[0]:9d} | {it[1]:.6f} | {it[2]:.6e} | {it[3]:.6e}")

x_vals = np.linspace(-1, 1, 100)
y_vals = g(x_vals)

plt.figure(figsize=(8, 5))
plt.plot(x_vals, y_vals, label=r"$g(x) = \cos(x)$", color="blue")
plt.plot(x_vals, x_vals, linestyle="dashed", color="red", label="y = x")

x_points = [it[1] for it in iteraciones]
y_points = [g(x) for x in x_points]
plt.scatter(x_points, y_points, color="black", zorder=3)
plt.plot(x_points, y_points, linestyle="dotted", color="black", label="Iteraciones")

plt.xlabel("x")
plt.ylabel("g(x)")
plt.legend()
plt.grid(True)
plt.title("Método de Punto Fijo")
plt.show()

plt.figure(figsize=(8, 5))
plt.plot(range(1, len(errores_abs) + 1), errores_abs, marker="o", label="Error absoluto")
plt.plot(range(1, len(errores_rel) + 1), errores_rel, marker="s", label="Error relativo")
plt.xlabel("Iteración")
plt.ylabel("Error")
plt.yscale("log")
plt.legend()
plt.grid(True)
plt.title("Evolución de los Errores")
plt.show()